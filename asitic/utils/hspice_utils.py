# This script is used to generate netlist for running HSPICE

import skrf as rf
import os
import ast
import yaml
import shutil
import errno
import subprocess
import sys
PYTCOIL_DIR = os.environ['PYTCOIL_DIR']
HSPICE_WORK_DIR = os.environ['HSPICE_WORK_DIR']
ASITIC_WORK_DIR = os.environ['ASITIC_WORK_DIR']
from utils import eq_ckt

# def hspice_del_sp():
#     """
#     Delete old HSPICE .sp files 
#     """
#     dir_name = './hspice'
#     test = os.listdir(dir_name)
#     for item in test:
#         if item.endswith('.sh'):
#             pass
#         else:
#             os.remove(os.path.join(dir_name, item))
#             print('** Old HSPICE files are all deleted. **')

def hspice_del_sp(tcoil_num, mode='train'):
    """
    Delete old HSPICE .sp files 
    """    

    
    location= f'{HSPICE_WORK_DIR}/{mode}'

    try:
        for i in range(tcoil_num):
            dir = 'tcoil{}'.format(i)
            path = os.path.join(location, dir)
            shutil.rmtree(path, ignore_errors = False)
            print('** Old HSPICE files for tcoil{} are deleted. **'.format(i))
    except:
        print('Manual deleting maybe required.')


class HspiceProcessing():
    
    def __init__(self, mode):
        self.mode = mode
        self.stream = open(f'{PYTCOIL_DIR}/asitic/sim_setup_asitic.yaml','r')
        self.sim_setups = yaml.load(self.stream, yaml.SafeLoader)
        self.tcoil_num_old = self.sim_setups['tcoil_num_old']
        self.tcoil_num_new = self.sim_setups['tcoil_num_new']
        self.tcoil_num_test = self.sim_setups['tcoil_num_test']

        self.freq_start = float(self.sim_setups['freq_start'])
        self.freq_stop = float(self.sim_setups['freq_stop'])
        self.freq_step = float(self.sim_setups['freq_step'])
        self.hspice_ser_opt = self.sim_setups['hspice_ser_opt']
        self.middle_branch = self.sim_setups['middle_branch']
        
        if self.mode == 'test':
            self.tcoil_num_old = 0
            self.tcoil_num_new = self.tcoil_num_test
        elif self.mode == 'train':
            None
        else:
            print('Wrong entry for "mode", should be either "train" or "test".')

    def hspice_tcoil_ext(self,
                      slicer_sw_a = False, slicer_a = 1, 
                      guess_sw_a = False, guess_a = [1,1], 
                      slicer_sw_b = False, slicer_b = 1, 
                      guess_sw_b = False, guess_b = [1,1], shell_script = True):
        """
        This function generate the t-coil netlist for HSPICE to run to extract
        Cbr and k. A Shell script will be generated by the end so all extractions
        can be done in one-click.
    
        Parameters
        ----------
        tcoil_num : int
            number of inductors.
        hspice_ser_opt : boolean, optional
            Using HSPICE to find series components or not. The default is True. If
            it is False, then function "series_ext" from "eq_ckt" module will be used.
        middle_branch : boolean, optional
            Whether included the middle branch parasitic or not. The default is True.
            If False, the t-coil's parasitic will be extracted as a pi-model.
        slicer_sw_a : boolean, optional
            By defult it is False, so the function will automatically neglect
            the first lower half of the frequency point data used for linear
            regression analysis for parasitic extraction; in case you would like
            to specify how many data point from the low frequency to skip, set this
            to True. This is for "ind a".
        slicer_a : int, optional
            When slicer_sw is set to True, this input controls how many data point
            from the low frequency to skip. This is for "ind a". The default is 1.
        guess_sw_a : boolean, optional; only effective when "hspice_ser_opt = False"
            Initial guess switch, if it is set to True, 
            the list value of guess input will be used for the intial guess
            value of Lskin and Rskin. This is for "ind a". The default is False.
        guess_a : list, optional; only effective when "hspice_ser_opt = False"
            list [Lskin, Rskin] of intial guess value for Lskin (in nH) and Rskin (in Ohm). 
            This is for "ind a". The default is [1,1].
        slicer_sw_b : boolean, optional
            Same as slicer_sw1 but for "ind b" of the t-coil. The default is False.
        slicer_b : int , optional
            Same as slicer1 but for "ind b" of the t-coil. The default is 1.
        guess_sw_b : boolean, optional; only effective when "hspice_ser_opt = False"
            Same as guess_sw1 but for "ind b" of the t-coil. The default is False.
        guess_b : list, optional; only effective when "hspice_ser_opt = False"
            Same as guess1 but for "ind b" of the t-coil. The default is [1,1].
    
        Returns
        -------
        None.
    
        """
      
          
        for i in range(self.tcoil_num_old, self.tcoil_num_new):
            tcoil_a = rf.Network('{}/{}/S_tcoil{}_a.s2p'.format(ASITIC_WORK_DIR,self.mode,i))
            tcoil_b = rf.Network('{}/{}/S_tcoil{}_b.s2p'.format(ASITIC_WORK_DIR,self.mode,i))
            tcoil_ab = rf.Network('{}/{}/S_tcoil{}_ab.s2p'.format(ASITIC_WORK_DIR,self.mode,i))
        
            
            two_pi_eq_ckt_list = eq_ckt.two_pi_eq_ckt(tcoil_a, tcoil_b, tcoil_ab, self.middle_branch,
                      slicer_sw_a, slicer_a, 
                      guess_sw_a, guess_a, 
                      slicer_sw_b, slicer_b, 
                      guess_sw_b, guess_b)
            
            if self.hspice_ser_opt == True:
                print('** HSPICE optimization for series components are used. ** \n')
                with open('{}/{}/tcoil{}/tcoil{}_a_ext.ma0'.format(HSPICE_WORK_DIR,self.mode,i,i),'r') as hspice_ser:
                    ser_output = []
                    for output in hspice_ser.readlines():
                        ser_output.append(str.split(output))
                    La = ser_output[7][1]
                    La_skin = ser_output[7][2]
                    Ra = ser_output[7][3]
                    Ra_skin = ser_output[8][0]
                    
                with open('{}/{}/tcoil{}/tcoil{}_b_ext.ma0'.format(HSPICE_WORK_DIR,self.mode,i,i),'r') as hspice_ser:
                    ser_output = []
                    for output in hspice_ser.readlines():
                        ser_output.append(str.split(output))
                    Lb = ser_output[7][1]
                    Lb_skin = ser_output[7][2]
                    Rb = ser_output[7][3]
                    Rb_skin = ser_output[8][0]
    
            else:
                print('** Linear regression optimization for series components are used. ** \n')
                La, Ra, La_skin, Ra_skin = two_pi_eq_ckt_list[0]
                Lb, Rb, Lb_skin, Rb_skin = two_pi_eq_ckt_list[1]
            
            if self.middle_branch == True:
                Cox_in, Rsub_in, Csub_in = two_pi_eq_ckt_list[2]
                Cox_mid, Rsub_mid, Csub_mid = two_pi_eq_ckt_list[3]
                Cox_out, Rsub_out, Csub_out = two_pi_eq_ckt_list[4]
            else:
                Cox_in, Rsub_in, Csub_in = two_pi_eq_ckt_list[2]
                Cox_out, Rsub_out, Csub_out = two_pi_eq_ckt_list[3]
                
            filename = '{}/{}/tcoil{}/tcoil{}_ext.sp'.format(HSPICE_WORK_DIR,self.mode,i,i)
            if not os.path.exists(os.path.dirname(filename)):
                try:
                    os.makedirs(os.path.dirname(filename))
                except OSError as exc: # Guard against race condition
                    if exc.errno != errno.EEXIST:
                        raise
            
            with open(filename,'w') as out:
                lines = []
                lines.append('** Extracting coupling factor k and bridging capacitor Cbr of tcoil{} ** \n'.format(i))
                lines.append('.option acct nomod post=2 \n\n')
                lines.append('.net v(p2) vin rout=50 rin=50 \n\n')
                lines.append('vin p1 gnd AC 1 \n\n')
                lines.append('La        p1      3      {} \n'.format(La))
                lines.append('Ra        3       p3     {} \n'.format(Ra))
                lines.append('La_skin   3       10     {} \n'.format(La_skin))
                lines.append('Ra_skin   10      p3     {} \n'.format(Ra_skin))
                lines.append('Cox_in    p1      1      {} \n'.format(Cox_in))
                lines.append('Csub_in   1       gnd    {} \n'.format(Csub_in))
                lines.append('Rsub_in   1       gnd    {} \n'.format(Rsub_in))
                if self.middle_branch == True:
                    lines.append('Cox_mid   p3      2      {} \n'.format(Cox_mid))
                    lines.append('Csub_mid  2       gnd    {} \n'.format(Csub_mid))
                    lines.append('Rsub_mid  2       gnd    {} \n'.format(Rsub_mid))
                else:
                    lines.append('** no middle branch **\n')
                    lines.append('** no middle branch **\n')
                    lines.append('** no middle branch **\n')
                lines.append('Lb        p3      4      {} \n'.format(Lb))
                lines.append('Rb        4       p2     {} \n'.format(Rb))
                lines.append('Lb_skin   4       20     {} \n'.format(Lb_skin))
                lines.append('Rb_skin   20      p2     {} \n'.format(Rb_skin))
                lines.append('Cox_out   p2      5      {} \n'.format(Cox_out))
                lines.append('Csub_out  5       gnd    {} \n'.format(Csub_out))
                lines.append('Rsub_out  5       gnd    {} \n'.format(Rsub_out))
                lines.append('Cbr       p1      p2     Cbr \n')
                lines.append('Kab       La      Lb     Kab \n\n')
                lines.append('.param \n')
                lines.append('+ Cbr = OPT1(1f,0.1f,100f) \n')
                lines.append('+ Kab = OPT1(0.1,0.1,1) \n\n')
                
                lines.append('.AC data=measured optimize=opt1 \n')
                lines.append('+ results=comp1,comp2,comp3,comp4,comp5,comp6,comp7,comp8 \n') 
                lines.append('+ model=converge \n')
                lines.append('.model converge opt relin=1e-4 relout=1e-4 close=10 itropt=100 \n')
                lines.append('.measure ac comp1 err1 par(s11m) s11(m) \n')
                lines.append('.measure ac comp2 err1 par(s11p) s11(p) \n')
                lines.append('.measure ac comp3 err1 par(s12m) s12(m) \n')
                lines.append('.measure ac comp4 err1 par(s12p) s12(p) \n')
                lines.append('.measure ac comp5 err1 par(s21m) s21(m) \n')
                lines.append('.measure ac comp6 err1 par(s21p) s21(p) \n')
                lines.append('.measure ac comp7 err1 par(s22m) s22(m) \n')
                lines.append('.measure ac comp8 err1 par(s22p) s22(p) \n')
                lines.append('.ac data=measured \n\n')
                
                lines.append('.data measured \n')
                lines.append('FREQ    s11m    s11p    s12m    s12p    s21m    s21p    s22m    s22p \n')
         
                with open('{}/{}/S_tcoil{}_ab.s2p'.format(ASITIC_WORK_DIR,self.mode,i),'r') as S_params:
                    for s2p in S_params.readlines()[27:]:
                        lines.append(s2p)
                
                lines.append('\n\n')
                lines.append('.enddata \n')
                
                lines.append('.param freq={}, s11m = 0, s11p = 0, s12m = 0, s12p = 0, s21m =0, \n'.format(self.freq_start))
                lines.append('+s21p =0, s22m =0, s22p = 0 \n')
                lines.append('.end')
                
                out.writelines(lines)
            
            print('** HSPICE netlist tcoil{}_ext.sp for extracting Cbr and Kab are generated **'.format(i))
            print('** HSPICE will now run netlist tcoil{}_ext.sp ** \n'.format(i))
            
            try:
                subprocess.run(['hspice', f'-C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_ext.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_ext.lis \n'])
            except:
                print('HSPICE is not sourced, so simulations did not run sucessfully; shell script is generated instead for later simulations.')
                shell_script = True
            
        ###################################################
        # This script is used to generate shell script to run HSPICE on 
        # multiple testbenches
        ###################################################
    
        if shell_script == True:
            with open('{}/{}/run_tcoil_ext.sh'.format(HSPICE_WORK_DIR,self.mode),'w') as out:
                lines = []
                lines.append('#!/bin/tcsh \n')
                for i in range(self.tcoil_num_old, self.tcoil_num_new):
                    lines.append(f'hspice -C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_ext.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_ext.lis \n')
                
                out.writelines(lines)
            
            print('** Shell script for running HSPICE scripts for extracting Cbr and Kab are generated ** \n')
        else:
            None



    def hspice_tcoil_a_b_ext(self, slicer_sw_a = False, slicer_a = 1,
                             slicer_sw_b = False, slicer_b = 1, shell_script = True):
        """
        This script is used to generate HSPICE netlist to extract series component
        La/Lb, Ra/Lb, La_skin/Lb_skin, Ra_skin/Lb_skin. By the end a Shell script
        will be generated so extractions can be done for mass designs.
    
        Parameters
        ----------
        tcoil_num : int
            Number od inductor design.
        slicer_sw_a : boolean, optional
            By defult it is False, so the function will automatically neglect
            the first lower half of the frequency point data used for linear
            regression analysis for parasitic extraction; in case you would like
            to specify how many data point from the low frequency to skip, set this
            to True. This is for "ind a".
        slicer_a : int, optional
            When slicer_sw is set to True, this input controls how many data point
            from the low frequency to skip. This is for "ind a". The default is 1.
        slicer_sw_b : boolean, optional
            Same as slicer_sw1 but for "ind b" of the t-coil. The default is False.
        slicer_b : int , optional
            Same as slicer1 but for "ind b" of the t-coil. The default is 1.
    
        Returns
        -------
        None.
    
        """
                 
                
    
        for i in range(self.tcoil_num_old, self.tcoil_num_new):
            tcoil_a = rf.Network('{}/{}/S_tcoil{}_a.s2p'.format(ASITIC_WORK_DIR,self.mode,i))
            tcoil_b = rf.Network('{}/{}/S_tcoil{}_b.s2p'.format(ASITIC_WORK_DIR,self.mode,i))
    
            sub_para_a = eq_ckt.sub_para_ext(tcoil_a, slicer_sw_a, slicer_a)
            sub_para_b = eq_ckt.sub_para_ext(tcoil_b, slicer_sw_b, slicer_b)
    
            flag_a = sub_para_a[2]
            flag_b = sub_para_b[2]
            if flag_a  == False and flag_b == False:
                Cox_in_a, Rsub_in_a, Csub_in_a = sub_para_a[0]
                Cox_out_a, Rsub_out_a, Csub_out_a = sub_para_a[1]
                Cox_in_b, Rsub_in_b, Csub_in_b = sub_para_b[0]
                Cox_out_b, Rsub_out_b, Csub_out_b = sub_para_b[1]
            elif flag_a  == False and flag_b == True:
                Cox_in_a, Rsub_in_a, Csub_in_a = sub_para_a[0]
                Cox_out_a, Rsub_out_a, Csub_out_a = sub_para_a[1]
                Cox_in_b, Rsub_in_b, Csub_in_b = Cox_in_a, Rsub_in_a, Csub_in_a
                Cox_out_b, Rsub_out_b, Csub_out_b = Cox_out_a, Rsub_out_a, Csub_out_a
            elif flag_a  == True and flag_b == False:
                Cox_in_b, Rsub_in_b, Csub_in_b = sub_para_b[0]
                Cox_out_b, Rsub_out_b, Csub_out_b = sub_para_b[1]
                Cox_in_a, Rsub_in_a, Csub_in_a = Cox_in_b, Rsub_in_b, Csub_in_b
                Cox_out_a, Rsub_out_a, Csub_out_a = Cox_out_b, Rsub_out_b, Csub_out_b
            else:
                print('** Bad numerical results. Please use pi-model for the tcoil instead. ** \n')
                
            filename = '{}/{}/tcoil{}/tcoil{}_a_ext.sp'.format(HSPICE_WORK_DIR,self.mode,i,i)
            if not os.path.exists(os.path.dirname(filename)):
                try:
                    os.makedirs(os.path.dirname(filename))
                except OSError as exc: # Guard against race condition
                    if exc.errno != errno.EEXIST:
                        raise
            
            with open(filename, 'w') as out:
                lines = []
                lines.append('** Extracting series components ind a of tcoil{} ** \n'.format(i))
                lines.append('.option acct nomod post=2 \n\n')
                lines.append('.net v(p3) vin rout=50 rin=50 \n\n')
                lines.append('vin p1 gnd AC 1 \n\n')
                lines.append('La        p1      3      La \n')
                lines.append('Ra        3       p3     Ra \n')
                lines.append('La_skin   3       4      La_skin \n')
                lines.append('Ra_skin   4       p3     Ra_skin \n')
                lines.append('Cox_in    p1      1      {} \n'.format(Cox_in_a))
                lines.append('Csub_in   1       gnd    {} \n'.format(Csub_in_a))
                lines.append('Rsub_in   1       gnd    {} \n'.format(Rsub_in_a))
    
                lines.append('Cox_out   p3      2      {} \n'.format(Cox_out_a))
                lines.append('Csub_out  2       gnd    {} \n'.format(Csub_out_a))
                lines.append('Rsub_out  2       gnd    {} \n\n'.format(Rsub_out_a))
                #lines.append('Cbr       p1      p3     Cbr \n')
                
                lines.append('.param \n')
                #lines.append('+ Cbr = OPT1(1f,0.1f,1p) \n')
                lines.append('+ La = OPT1(1n,10p,20n) \n')
                lines.append('+ La_skin = OPT1(1n,10p,20n) \n')
                lines.append('+ Ra = OPT1(10,.1,10k) \n')
                lines.append('+ Ra_skin = OPT1(10,.1,10k) \n')
                
                lines.append('.AC data=measured optimize=opt1 \n')
                lines.append('+ results=comp1,comp2,comp3,comp4,comp5,comp6,comp7,comp8 \n') 
                lines.append('+ model=converge \n')
                lines.append('.model converge opt relin=1e-4 relout=1e-4 close=10 itropt=100 \n')
                lines.append('.measure ac comp1 err1 par(s11m) s11(m) \n')
                lines.append('.measure ac comp2 err1 par(s11p) s11(p) \n')
                lines.append('.measure ac comp3 err1 par(s12m) s12(m) \n')
                lines.append('.measure ac comp4 err1 par(s12p) s12(p) \n')
                lines.append('.measure ac comp5 err1 par(s21m) s21(m) \n')
                lines.append('.measure ac comp6 err1 par(s21p) s21(p) \n')
                lines.append('.measure ac comp7 err1 par(s22m) s22(m) \n')
                lines.append('.measure ac comp8 err1 par(s22p) s22(p) \n')
                lines.append('.ac data=measured \n\n')
                
                lines.append('.data measured \n')
                lines.append('FREQ    s11m    s11p    s12m    s12p    s21m    s21p    s22m    s22p \n')
         
                with open('{}/{}/S_tcoil{}_a.s2p'.format(ASITIC_WORK_DIR,self.mode,i),'r') as S_params:
                    for s2p in S_params.readlines()[27:]:
                        lines.append(s2p)
                
                lines.append('\n\n')
                lines.append('.enddata \n')
                
                lines.append('.param freq={}, s11m = 0, s11p = 0, s12m = 0, s12p = 0, s21m =0, \n'.format(self.freq_start))
                lines.append('+s21p =0, s22m =0, s22p = 0 \n')
                lines.append('.end')
                
                out.writelines(lines)
    
            print('** HSPICE netlist tcoil{}_a.sp for extracting series components La and Ra is generated **'.format(i))
            print('** HSPICE will now run netlist tcoil{}_a.sp ** \n'.format(i))
            
            try:
                subprocess.run(['hspice', f'-C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_a_ext.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_a_ext.lis \n'])
            except:
                print('HSPICE is not sourced, so simulations did not run sucessfully; shell script is generated instead for later simulations.')
                shell_script = True
    
            ###################################################
            # This script is used to generate HSPICE netlist to extract series component
            # Lb, Rb, Lb_skin, Rb_skin
            ################################################### 
            
            filename = '{}/{}/tcoil{}/tcoil{}_b_ext.sp'.format(HSPICE_WORK_DIR,self.mode,i,i)
            if not os.path.exists(os.path.dirname(filename)):
                try:
                    os.makedirs(os.path.dirname(filename))
                except OSError as exc: # Guard against race condition
                    if exc.errno != errno.EEXIST:
                        raise
            
            with open(filename,'w') as out:
                lines = []
                lines.append('** Extracting series components ind b of tcoil{} ** \n'.format(i))
                lines.append('.option acct nomod post=2 \n\n')
                lines.append('.net v(p3) vin rout=50 rin=50 \n\n')
                lines.append('vin p1 gnd AC 1 \n\n')
                lines.append('Lb        p1      3      Lb \n')
                lines.append('Rb        3       p3     Rb \n')
                lines.append('Lb_skin   3       4      Lb_skin \n')
                lines.append('Rb_skin   4       p3     Rb_skin \n')
                lines.append('Cox_in    p1      1      {} \n'.format(Cox_in_b))
                lines.append('Csub_in   1       gnd    {} \n'.format(Csub_in_b))
                lines.append('Rsub_in   1       gnd    {} \n'.format(Rsub_in_b))
    
                lines.append('Cox_out   p3      2      {} \n'.format(Cox_out_b))
                lines.append('Csub_out  2       gnd    {} \n'.format(Csub_out_b))
                lines.append('Rsub_out  2       gnd    {} \n\n'.format(Rsub_out_b))
                #lines.append('Cbr       p1      p3     Cbr \n')
                
                lines.append('.param \n')
                #lines.append('+ Cbr = OPT1(1f,0.1f,100f) \n')
                lines.append('+ Lb = OPT1(1n,10p,20n) \n')
                lines.append('+ Lb_skin = OPT1(1n,10p,20n) \n')
                lines.append('+ Rb = OPT1(10,.1,10k) \n')
                lines.append('+ Rb_skin = OPT1(10,.1,10k) \n')
                
                lines.append('.AC data=measured optimize=opt1 \n')
                lines.append('+ results=comp1,comp2,comp3,comp4,comp5,comp6,comp7,comp8 \n') 
                lines.append('+ model=converge \n')
                lines.append('.model converge opt relin=1e-4 relout=1e-4 close=10 itropt=100 \n')
                lines.append('.measure ac comp1 err1 par(s11m) s11(m) \n')
                lines.append('.measure ac comp2 err1 par(s11p) s11(p) \n')
                lines.append('.measure ac comp3 err1 par(s12m) s12(m) \n')
                lines.append('.measure ac comp4 err1 par(s12p) s12(p) \n')
                lines.append('.measure ac comp5 err1 par(s21m) s21(m) \n')
                lines.append('.measure ac comp6 err1 par(s21p) s21(p) \n')
                lines.append('.measure ac comp7 err1 par(s22m) s22(m) \n')
                lines.append('.measure ac comp8 err1 par(s22p) s22(p) \n')
                lines.append('.ac data=measured \n\n')
                
                lines.append('.data measured \n')
                lines.append('FREQ    s11m    s11p    s12m    s12p    s21m    s21p    s22m    s22p \n')
         
                with open('{}/{}/S_tcoil{}_b.s2p'.format(ASITIC_WORK_DIR,self.mode,i),'r') as S_params:
                    for s2p in S_params.readlines()[27:]:
                        lines.append(s2p)
                
                lines.append('\n\n')
                lines.append('.enddata \n')
                
                lines.append('.param freq={}, s11m = 0, s11p = 0, s12m = 0, s12p = 0, s21m =0, \n'.format(self.freq_start))
                lines.append('+s21p =0, s22m =0, s22p = 0 \n')
                lines.append('.end')
                
                out.writelines(lines)
    
            print('** HSPICE netlist tcoil{}_a.sp for extracting series components Lb and Rb is generated **'.format(i))
            print('** HSPICE will now run netlist tcoil{}_b.sp ** \n'.format(i))
            
            try:
                subprocess.run(['hspice', f'-C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_b_ext.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_b_ext.lis \n'])
            except:
                print('HSPICE is not sourced, so simulations did not run sucessfully; shell script is generated instead for later simulations.')
                shell_script = True
    
        if shell_script == True:
            with open('{}/{}/run_tcoil_a_b_ext.sh'.format(HSPICE_WORK_DIR,self.mode),'w') as out:
                lines = []
                lines.append('#!/bin/tcsh \n')
                for i in range(self.tcoil_num_old, self.tcoil_num_new):
                    lines.append(f'hspice -C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_a_ext.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_a_ext.lis \n')
                    lines.append(f'hspice -C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_b_ext.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}_b_ext.lis \n')
                
                out.writelines(lines)
            
            print('** Shell script for running HSPICE scripts for extracting series components of "ind a" and "ind b" are generated ** \n')
        else:
            None

    def hspice_tcoil(self,
                      slicer_sw1 = False, slicer1 = 1, 
                      guess_sw1 = False, guess1 = [1,1], 
                      slicer_sw2 = False, slicer2 = 1, 
                      guess_sw2 = False, guess2 = [1,1], shell_script = True):
        """
        This function generate the t-coil netlist for HSPICE after all its equivalent
        circuit components are extracted and is ready for 3-port simulation.
        A Shell script will be generated by the end so all simulations
        can be done for all inductors in one-click.
    
        Parameters
        ----------
        tcoil_num : int
            number of inductors.
        hspice_ser_opt : boolean, optional
            Using HSPICE to find series components or not. The default is True. If
            it is False, then function "series_ext" from "eq_ckt" module will be used.
        middle_branch : boolean, optional
            Whether included the middle branch parasitic or not. The default is True.
            If False, the t-coil's parasitic will be extracted as a pi-model.
        slicer_sw_a : boolean, optional
            By defult it is False, so the function will automatically neglect
            the first lower half of the frequency point data used for linear
            regression analysis for parasitic extraction; in case you would like
            to specify how many data point from the low frequency to skip, set this
            to True. This is for "ind a".
        slicer_a : int, optional
            When slicer_sw is set to True, this input controls how many data point
            from the low frequency to skip. This is for "ind a". The default is 1.
        guess_sw_a : boolean, optional; only effective when "hspice_ser_opt = False"
            Initial guess switch, if it is set to True, 
            the list value of guess input will be used for the intial guess
            value of Lskin and Rskin. This is for "ind a". The default is False.
        guess_a : list, optional; only effective when "hspice_ser_opt = False"
            list [Lskin, Rskin] of intial guess value for Lskin (in nH) and Rskin (in Ohm). 
            This is for "ind a". The default is [1,1].
        slicer_sw_b : boolean, optional
            Same as slicer_sw1 but for "ind b" of the t-coil. The default is False.
        slicer_b : int , optional
            Same as slicer1 but for "ind b" of the t-coil. The default is 1.
        guess_sw_b : boolean, optional; only effective when "hspice_ser_opt = False"
            Same as guess_sw1 but for "ind b" of the t-coil. The default is False.
        guess_b : list, optional; only effective when "hspice_ser_opt = False"
            Same as guess1 but for "ind b" of the t-coil. The default is [1,1].
    
        Returns
        -------
        None.
    
        """
    
          
    
        for i in range(self.tcoil_num_old, self.tcoil_num_new):
            tcoil_a = rf.Network('{}/{}/S_tcoil{}_a.s2p'.format(ASITIC_WORK_DIR,self.mode, i))
            tcoil_b = rf.Network('{}/{}/S_tcoil{}_b.s2p'.format(ASITIC_WORK_DIR,self.mode, i))
            tcoil_ab = rf.Network('{}/{}/S_tcoil{}_ab.s2p'.format(ASITIC_WORK_DIR,self.mode, i))
        
            two_pi_eq_ckt_list = eq_ckt.two_pi_eq_ckt(tcoil_a, tcoil_b, tcoil_ab, 
                      self.middle_branch, slicer_sw1, slicer1, 
                      guess_sw1, guess1, 
                      slicer_sw2, slicer2, 
                      guess_sw2, guess2)
            
            if self.hspice_ser_opt == True:
                print('HSPICE optimization for series components are used.')
                with open('{}/{}/tcoil{}/tcoil{}_a_ext.ma0'.format(HSPICE_WORK_DIR,self.mode,i,i),'r') as hspice_ser:
                    ser_output = []
                    for output in hspice_ser.readlines():
                        ser_output.append(str.split(output))
                    La = ser_output[7][1]
                    La_skin = ser_output[7][2]
                    Ra = ser_output[7][3]
                    Ra_skin = ser_output[8][0]
                    
                with open('{}/{}/tcoil{}/tcoil{}_b_ext.ma0'.format(HSPICE_WORK_DIR,self.mode,i,i),'r') as hspice_ser:
                    ser_output = []
                    for output in hspice_ser.readlines():
                        ser_output.append(str.split(output))
                    Lb = ser_output[7][1]
                    Lb_skin = ser_output[7][2]
                    Rb = ser_output[7][3]
                    Rb_skin = ser_output[8][0]
            else:
                La, Ra, La_skin, Ra_skin = two_pi_eq_ckt_list[0]
                Lb, Rb, Lb_skin, Rb_skin = two_pi_eq_ckt_list[1]
                
            if self.middle_branch == True: 
                Cox_in, Rsub_in, Csub_in = two_pi_eq_ckt_list[2]
                Cox_mid, Rsub_mid, Csub_mid = two_pi_eq_ckt_list[3]
                Cox_out, Rsub_out, Csub_out = two_pi_eq_ckt_list[4]
            else:
                Cox_in, Rsub_in, Csub_in = two_pi_eq_ckt_list[2]
                Cox_out, Rsub_out, Csub_out = two_pi_eq_ckt_list[3]
                
            # Read Cbr and Kab values from HSPICE optimization output
            with open('{}/{}/tcoil{}/tcoil{}_ext.ma0'.format(HSPICE_WORK_DIR,self.mode,i,i),'r') as hspice_opt:
                opt_output = []
                for output in hspice_opt.readlines():
                    opt_output.append(str.split(output))
                Cbr = opt_output[6][1]
                Kab = opt_output[6][2]
                
            filename = '{}/{}/tcoil{}/tcoil{}.sp'.format(HSPICE_WORK_DIR,self.mode,i,i)
            if not os.path.exists(os.path.dirname(filename)):
                try:
                    os.makedirs(os.path.dirname(filename))
                except OSError as exc: # Guard against race condition
                    if exc.errno != errno.EEXIST:
                        raise
                
            with open(filename,'w') as out:
                lines = []
                lines.append('** Simulating the whole circuit after Cbr and Kab are extracted for tcoil{} ** \n\n'.format(i))
                lines.append('** port declaration ** \n')
                lines.append('PS1 p1 gnd dc=0 ac=1 zo=50 port=1 \n')
                lines.append('PS3 p3 gnd dc=0 ac=1 zo=50 port=3 \n')
                lines.append('PS2 p2 gnd dc=0 ac=1 zo=50 port=2 \n\n')
                lines.append('** Equivalent circuit netlist ** \n')
                lines.append('La        p1      3      {} \n'.format(La))
                lines.append('Ra        3       p3     {} \n'.format(Ra))
                lines.append('La_skin   3       10     {} \n'.format(La_skin))
                lines.append('Ra_skin   10      p3     {} \n'.format(Ra_skin))
                lines.append('Cox_in    p1      1      {} \n'.format(Cox_in))
                lines.append('Csub_in   1       gnd    {} \n'.format(Csub_in))
                lines.append('Rsub_in   1       gnd    {} \n'.format(Rsub_in))
                if self.middle_branch == True:
                    lines.append('Cox_mid   p3      2      {} \n'.format(Cox_mid))
                    lines.append('Csub_mid  2       gnd    {} \n'.format(Csub_mid))
                    lines.append('Rsub_mid  2       gnd    {} \n'.format(Rsub_mid))
                else:
                    lines.append('** no middle branch **\n')
                    lines.append('** no middle branch **\n')
                    lines.append('** no middle branch **\n')
                lines.append('Lb        p3      4      {} \n'.format(Lb))
                lines.append('Rb        4       p2     {} \n'.format(Rb))
                lines.append('Lb_skin   4       20     {} \n'.format(Lb_skin))
                lines.append('Rb_skin   20      p2     {} \n'.format(Rb_skin))
                lines.append('Cox_out   p2      5      {} \n'.format(Cox_out))
                lines.append('Csub_out  5       gnd    {} \n'.format(Csub_out))
                lines.append('Rsub_out  5       gnd    {} \n'.format(Rsub_out))
                lines.append('Cbr       p1      p2     {} \n'.format(Cbr))
                lines.append('Kab       La      Lb     {} \n\n'.format(Kab))
                
                lines.append('** Analysis ** \n')
                lines.append('.ac lin {} {} {} \n'.format(int(1+(self.freq_stop-self.freq_start)/self.freq_step),
                                                                  self.freq_start, self.freq_stop))
                lines.append('.LIN \n')
                lines.append('+ sparcalc=1 \n')
                lines.append('+ format=touchstone \n')
                lines.append('+ dataformat=ma \n\n')
                
                lines.append('.print S11 S21 \n')
                lines.append('.END')
                
                out.writelines(lines)
        
        
            print('** HSPICE netlist tcoil{}.sp is generated **'.format(i))
            print('** HSPICE will now run netlist tcoil{}.sp ** \n'.format(i))
            
            try:
                subprocess.run(['hspice', f'-C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}.lis \n'])
            except:
                print('HSPICE is not sourced, so simulations did not run sucessfully; shell script is generated instead for later simulations.')
                shell_script = True
        
        if shell_script == True:
            with open('{}/{}/run_tcoil.sh'.format(HSPICE_WORK_DIR,self.mode),'w') as out:
                lines = []
                lines.append('#!/bin/tcsh \n')
                for i in range(self.tcoil_num_old, self.tcoil_num_new):
                    lines.append('hspice -C -i {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}.sp -o {HSPICE_WORK_DIR}/{self.mode}/tcoil{i}/tcoil{i}.lis \n')
                
                out.writelines(lines)
                
            print('** Shell scripts for for running tcoil eq. ckt. simulations are generated ** \n')
        else:
            None